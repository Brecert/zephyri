{"version":3,"file":"index.js","sources":["../dist-src/router.js","../dist-src/http-router.js"],"sourcesContent":["/**\r\n * Router provides an interface for creating complex routes that can be used in an use-case agnostic way\r\n */\r\n/**\r\n * @hidden\r\n */\r\nconst escapeRegExp = (string) => string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n/**\r\n * @hidden\r\n *\r\n * Replaces all matches in a string with a value provided by a callback\r\n */\r\nconst replaceAll = (string, regex, cb) => {\r\n    // make sure that string actually has a match\r\n    while (regex.test(string)) {\r\n        // guranteed because already tested\r\n        string.match(regex).slice(1).map(val => {\r\n            string = string.replace(regex, cb(val));\r\n        });\r\n    }\r\n    return string;\r\n};\r\n/**\r\n * Compiles a route to a `RegExp` pattern\r\n *\r\n * ```typescript\r\n * compileRoute('/user/:id')\r\n * // /^\\/user\\/(?<id>[,a-zA-Z0-9%_-]*)(\\?[a-zA-Z0-9%_=&-]*)?$/\r\n *\r\n * compileRoute('/@(\\\\w{1,16})/get/:id')\r\n * // /^\\/@(\\w{1,16})\\/get\\/(?<id>[,a-zA-Z0-9%_-]*)(\\?[a-zA-Z0-9%_=&-]*)?$/\r\n * ```\r\n */\r\nexport const compileRoute = (route) => {\r\n    const replaced = route\r\n        .replace('**', '__DOUBLE_WILDCARD__')\r\n        .replace('*', \"[,a-zA-Z0-9_-]*\")\r\n        .replace(\"__DOUBLE_WILDCARD__\", \"[,/a-zA-Z0-9_-]*\");\r\n    const withCaptures = replaceAll(replaced, /:([,a-zA-Z0-9_-]*)/, val => `(?<${escapeRegExp(val)}>[,a-zA-Z0-9%_-]*)`);\r\n    let fin = `^${withCaptures}(\\\\?[a-zA-Z0-9%_=&-]*)?$`;\r\n    return new RegExp(fin);\r\n};\r\n/**\r\n * A use-case agnostic router for holding and matching routes\r\n *\r\n * @typeparam T  Where T is the types of the values passed from [[runPath]] to the [[RouteHandler]]\r\n */\r\nexport class Router {\r\n    constructor() {\r\n        /**\r\n         * The list of routes\r\n         */\r\n        this.routes = [];\r\n    }\r\n    /**\r\n     * Find a route that matches the path, returns undefined if nothing is found\r\n     */\r\n    findRoute(path) {\r\n        // tests based on order added, the order the paths were added matters!\r\n        return this.routes.find(({ route, handler }) => route.test(path));\r\n    }\r\n    /**\r\n     * Adds a route to match when testing paths\r\n     *\r\n     * The route handler is the callback that is executed when the program\r\n     */\r\n    addRoute(route, handler) {\r\n        this.routes.push({ route: compileRoute(route), handler });\r\n    }\r\n    /**\r\n     * Find and run the route handler for the path if any matches are found\r\n     *\r\n     * Optionally data can be passed to the handler\r\n     */\r\n    runPath(path, ...data) {\r\n        const route = this.findRoute(path);\r\n        if (route) {\r\n            // guranteed because tested earlier\r\n            route.handler(route.route.exec(path).groups || {}, ...data);\r\n        }\r\n    }\r\n}\r\n","import { Router } from './router.js';\r\n/**\r\n * A router specifically meant for use with HTTP servers\r\n *\r\n * ```typescript\r\n * import * as http from 'http';\r\n * import { HTTPRouter, URLReq } from 'zephyri';\r\n *\r\n * // IncomingMessage does not always have url or method\r\n * type Request = http.IncomingMessage & URLReq\r\n * type Response = http.ServerResponse\r\n *\r\n * const router = new HTTPRouter<Request, Response>()\r\n *  .on('GET', '/:param', (req, res, params) => res.end(JSON.stringify(params)))\r\n *  .on('GET', '/user/:id', (req, res, params) => res.end(params.id))\r\n *  .on('GET', '**', (req, res) => res.end('404'));\r\n *\r\n * // We cast req as Request because we know `url` and `method` is on `http.Server` incoming requests\r\n * http\r\n *  .createServer((req, res) => router.lookup(req as Request, res))\r\n *  .listen(3000)\r\n *\r\n * ```\r\n *\r\n * @typeparam T  where T is the type of `req` in the context of `(req, res, params)` for [[HttpRouterHandler]]\r\n * @typeparam U  where U is the type of `res` in the context of `(req, res, params)` for [[HttpRouterHandler]]\r\n */\r\nexport class HTTPRouter {\r\n    constructor() {\r\n        /**\r\n         * The base router\r\n         */\r\n        this.router = new Router();\r\n    }\r\n    /**\r\n     * Lookup a path and see if one exists, if it exists then the corresponding handler to the match will be called\r\n     *\r\n     * ```\r\n     * router.lookup('/user/1')\r\n     * ```\r\n     */\r\n    lookup(req, res) {\r\n        this.router.runPath(req.url, req, res);\r\n    }\r\n    /**\r\n     * Add a listener with a handler that will be called if a lookup match is found\r\n     *\r\n     * ```\r\n     * router.on('GET', '/user/:id', (req, res, params) => {\r\n     *   res.end(JSON.stringify(params.id))\r\n     * })\r\n     * ```\r\n     */\r\n    on(method, path, handler) {\r\n        /** @todo move the match logic to some a function like `recognize` or something for potential future memoization */\r\n        this.router.addRoute(path, (params, req, res) => {\r\n            if (req.method === method) {\r\n                handler(req, res, params);\r\n            }\r\n        });\r\n        return this;\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}